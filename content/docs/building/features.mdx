---
title: "Build Your Core Features"
---

# Build Your Core Features

Build the thing that makes users want to pay. This guide shows you how.

## The Shape of Every Feature

Most features follow the same pattern:

```
User Action → Data → Intelligence → State → Feedback
```

| Step | What happens | Ghoststack tool |
|------|--------------|-----------------|
| **User Action** | User provides input (username, query, file, click) | Form / UI |
| **Data** | Fetch from API or database | RapidAPI, Supabase, other APIs |
| **Intelligence** | Transform with code or AI | OpenRouter |
| **State** | Save results (optional) | Supabase |
| **Feedback** | Show results to user | UI, Email |

Once you understand this pattern, you can build anything.

---

## Example: Twitter Profile Summarizer

Let's walk through this based on a real feature: enter a Twitter username, get an AI summary of their recent tweets. For this example we use RapidAPI as data provider. 

> **Why RapidAPI?** RapidAPI is a marketplace with thousands of APIs — weather, finance, social media, news, and more. Instead of signing up for dozens of services and learning each one, you get unified access through one platform. It's the fastest way to add external data to your app.

### Step 1: Set Up RapidAPI MCP

1. Go to [rapidapi.com](https://rapidapi.com) → Search "Twttr API"
2. Subscribe (free tier available)
3. Click **MCP Playground** → Copy the config
4. Add it to your MCP config (see [Data APIs](/docs/integrations/data-apis))

### Step 2: Use Plan Mode

Switch Cursor to **Plan Mode**, then paste this prompt:

```
I want to build a Twitter Profile Summarizer.

How it works:
1. User enters a Twitter username on a dashboard page
2. Fetch their recent tweets from RapidAPI Twttr API
3. Send tweets to OpenRouter to generate a 2-3 sentence summary
4. Display the summary in a card

Technical requirements:
- Use lib/openrouter.ts for AI summarization
- Add a page to the dashboard
- Handle loading states and errors
- UI: daisyUI ONLY (no custom CSS, no other libs). @web https://daisyui.com/llms.txt

Use the Twttr API MCP to understand the API endpoints and response format. 
Follow @AGENTS.md patterns.
```

### Step 3: Review and Execute

1. Read Cursor's plan — does it make sense?
2. Ask follow-up questions if needed
3. Let Cursor build it
4. Test at `/dashboard/twitter`

---

## About the Tools

The example above uses **RapidAPI** for data and **OpenRouter** for AI — these are Ghoststack's recommended tools, but they're not required.

- **OpenRouter** gives you access to 100+ AI models (GPT-4, Claude, Llama, etc.) through one API. See [AI Integration](/docs/integrations/ai) for setup and usage.
- **RapidAPI** provides thousands of APIs in one place. See [Data APIs](/docs/integrations/data-apis) for more.

You can use any API or AI service you prefer — the pattern stays the same.

### Using Any API (No MCP)

If an API doesn't have an MCP, just describe it in your prompt:

```
I want to integrate [API NAME] for [PURPOSE].

API endpoint: [URL]
Authentication: [API key in header / query param / etc.]

Example response:
[PASTE EXAMPLE JSON FROM API DOCS]

Please create a server-side utility to call this API and use it in my feature.
Follow @AGENTS.md patterns.
```

---

## Complex Features: Script First, Integrate Later

When building features with **chained AI calls**, **multiple API calls**, or **complex data transformations**, the AI can struggle to get everything right in the full app context. There's a better way:

**Develop the core logic in a standalone script first.**

### Why This Works

- **Faster iteration**: Run with `node script.js` instead of full Next.js rebuild
- **Clear outputs**: See exact logs and responses without UI noise
- **Easier debugging**: Test and fix logic in isolation
- **Less context**: AI focuses on logic, not routing/UI/state

### When to Use This Pattern

- Chaining multiple OpenRouter calls (e.g., analyze → summarize → format)
- Complex API sequences (fetch → transform → aggregate → store)
- Data processing pipelines
- Multi-step workflows with error handling

### Example Prompt

```
I need to build the core logic for [FEATURE NAME] before integrating it into the app.

Create a standalone Node.js script that:
1. [STEP 1 - e.g., Fetches data from API X]
2. [STEP 2 - e.g., Sends to OpenRouter for analysis]
3. [STEP 3 - e.g., Processes response and formats output]

Requirements:
- Use fetch() for all HTTP calls
- Log each step clearly (input, output, errors)
- Use environment variables for API keys
- Add error handling for each API call
- Show the final output in a readable format

Test this with example data until it works correctly.
Once the logic is solid, we'll integrate it into the Next.js app.
```

### After Testing

Once your standalone script works:

```
The standalone script works correctly. Now integrate this logic into the app:

1. Create a utility function in lib/ with the core logic
2. Add an API route that calls this utility
3. Create the UI that calls the API route
4. Add loading states and error handling

Follow @AGENTS.md patterns.
```

---

## Your Turn: Build Any Feature

Use this template for any feature:

```
I want to build [FEATURE NAME].

How it works:
1. User [INPUT ACTION] on a dashboard page
2. Fetch [DATA] from [API NAME]
3. [Process with OpenRouter to... / Apply code logic to...]
4. Display [WHAT] in [UI STYLE - e.g., card, table, list]

Technical requirements:
- Use lib/openrouter.ts for AI processing (if needed)
- Add a page to the dashboard
- Handle loading states and errors
- UI: daisyUI ONLY (no custom CSS, no other libs). @web https://daisyui.com/llms.txt

Use the [API NAME] MCP to understand the API endpoints and response format.
Follow @AGENTS.md patterns.
```

**Examples you could build:**
- Weather dashboard (weather API → display forecast)
- News summarizer (news API → AI summary → display)
- Stock tracker (finance API → store watchlist → display prices)

---

## Storing Data

Need to save user data? Use Supabase:

```
I need to store [DATA TYPE - e.g., "saved summaries", "user preferences"].

Use the Supabase MCP to:
1. Create a table with appropriate columns
2. Enable RLS (users only see their own data)
3. Follow the existing users/subscriptions pattern
```

---

## Adding to the Dashboard

```
Add a new section to the dashboard for [FEATURE].

It should show [WHAT DATA/UI].
Add a link in the dashboard navigation.

Use DaisyUI. @web https://daisyui.com/llms.txt
Follow @AGENTS.md patterns.
```

---

## Testing

1. Does the input form work?
2. Does data load correctly?
3. Do loading states show?
4. Do errors display properly?
5. Does it look good on mobile?
